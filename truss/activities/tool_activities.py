"""Temporal activity routing tool-calls to a remote Model-Context-Protocol (MCP) server.

This module no longer keeps a *local* TOOL_REGISTRY.  Instead, every incoming
ToolCall is forwarded to the configured MCP server via
:pyfunc:`truss.core.mcp_client.default_manager`.  The returned content is
flattened into a JSON serialisable list so it can be stored in the database
as plain text.
"""
from __future__ import annotations

import json
from typing import Any, Dict, List, Tuple
import asyncio

from temporalio import activity

from truss.core.client import MCPClient
from truss.core.connectors import BaseConnector
from truss.data_models import ToolCall, ToolCallResult
import logging

logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(filename)s - %(lineno)d - %(message)s'))
logger.addHandler(handler)
logger.setLevel(logging.INFO)

# Singleton MCP client managing connectors for all servers
_mcp_client = MCPClient()

# Lock guarding first-time session creation so multiple concurrent activities
# don't race when the same server is referenced the very first time.
_session_lock: asyncio.Lock = asyncio.Lock()

async def _get_connector(server_cfg: dict) -> "BaseConnector":  # noqa: F821 – forward ref
    """Return an initialised connector for *server_cfg*.

    A session is created lazily on first access and re-used afterwards.  The
    function always returns the connector instance (rather than the
    MCPSession) so callers can directly use  ``list_tools`` / ``call_tool``.
    """

    name = server_cfg["name"]

    # Fast path – already cached
    if name in _mcp_client.sessions:
        return _mcp_client.get_session(name).connector

    # Slow path – create & initialise under lock
    async with _session_lock:
        if name not in _mcp_client.sessions:  # re-check after awaiting lock
            _mcp_client.add_server(name, server_cfg)
            await _mcp_client.create_session(name, auto_initialize=True)

        return _mcp_client.get_session(name).connector

@activity.defn(name="GetTools")
async def get_tools(agent_config: dict) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """Fetch tools from MCP servers specified in the agent configuration."""
    tools_payload = None
    server_tools = {}
    all_remote_tools = []
    if agent_config.get("mcp_servers"):
        for mcp_server in agent_config["mcp_servers"]:
            try:
                connector = await _get_connector(mcp_server)
                remote_tools = await connector.list_tools()
                if remote_tools:
                    # Convert Tool objects to plain dicts so downstream code that
                    # expects subscriptable items (e.g. t["name"]) keeps working.
                    remote_tools_dicts = [t.__dict__ if hasattr(t, "__dict__") else t for t in remote_tools]
                    server_tools[mcp_server["name"]] = remote_tools_dicts
                    all_remote_tools.extend(remote_tools_dicts)
            except Exception as e:
                logger.warning(
                    "Failed to introspect tools from MCP server %s: %s",
                    mcp_server.get("name"),
                    e,
                )

        if all_remote_tools:
            processed_tools = []
            for t in all_remote_tools:
                if isinstance(t, dict):
                    input_schema = t.get("inputSchema", {})
                    name = t.get("name", "")
                    description = t.get("description", "") or ""
                else:  # fallback to attribute style
                    input_schema = getattr(t, "inputSchema", {})
                    name = getattr(t, "name", "")
                    description = getattr(t, "description", "") or ""

                # Ensure the parameters schema is a valid JSON schema for objects
                if not input_schema or (input_schema.get("type") == "object" and "properties" not in input_schema):
                    parameters = {"type": "object", "properties": {}}
                else:
                    parameters = input_schema

                processed_tools.append(
                    {
                        "type": "function",
                        "function": {
                            "name": name,
                            "description": description,
                            "parameters": parameters,
                        },
                    }
                )
            tools_payload = processed_tools
            
    return tools_payload, server_tools

@activity.defn(name="ExecuteTool")
async def execute_tool_activity(  # noqa: D401 – imperative style
    tool_call: ToolCall,
    mcp_server_config: dict,  
) -> ToolCallResult:
    """Proxy *tool_call* execution to the given *mcp_server*.

    Parameters
    ----------
    tool_call
        The tool invocation request generated by the LLM / agent.
    mcp_server
        Logical name of the MCP server to use.
    """
    try:
        connector = await _get_connector(mcp_server_config)

        mcp_result = await connector.call_tool(tool_call.name, tool_call.arguments)  
        def _serialise_part(part: Any) -> str:
            if getattr(part, "type", "text") == "text":
                return str(getattr(part, "text", part))
            return "<non-text result>"

        content_json = json.dumps([_serialise_part(p) for p in getattr(mcp_result, "content", [])])

        return ToolCallResult(tool_call_id=tool_call.id, content=content_json) 
    except Exception as e:
        logger.error(f"Error executing tool {tool_call.name}: {e}")
        raise e
