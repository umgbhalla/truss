"""Temporal activity routing tool-calls to a remote Model-Context-Protocol (MCP) server.

This module no longer keeps a *local* TOOL_REGISTRY.  Instead, every incoming
ToolCall is forwarded to the configured MCP server via
:pyfunc:`truss.core.mcp_client.default_manager`.  The returned content is
flattened into a JSON serialisable list so it can be stored in the database
as plain text.
"""
from __future__ import annotations

import json
from typing import Any, Dict, List, Tuple

from temporalio import activity

from truss.core.mcp_client import default_manager
from truss.data_models import ToolCall, ToolCallResult, MCPServerConfig
import logging

logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(filename)s - %(lineno)d - %(message)s'))
logger.addHandler(handler)
logger.setLevel(logging.INFO)

@activity.defn(name="GetTools")
async def get_tools(agent_config: dict) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """Fetch tools from MCP servers specified in the agent configuration."""
    tools_payload = None
    server_tools = {}
    all_remote_tools = []
    if agent_config.get("mcp_servers"):
        for mcp_server in agent_config["mcp_servers"]:
            try:
                server_config = MCPServerConfig(**mcp_server)
                session = await default_manager().get_session(server_config)
                remote_tools_resp = await session.list_tools()
                if remote_tools_resp:
                    tools_for_server = getattr(remote_tools_resp, "tools", [])
                    server_tools[mcp_server["name"]] = tools_for_server
                    all_remote_tools.extend(tools_for_server)
            except Exception as e:
                logger.warning(f"Failed to introspect tools from MCP server {mcp_server.get('name')}: {e}")

        if all_remote_tools:
            tools_payload = [
                {
                    "type": "function",
                    "function": {
                        "name": getattr(t, "name", ""),
                        "description": getattr(t, "description", "") or "",
                        "parameters": (lambda s: s if s and s.get("type") != "object" or "properties" in s else {**s, "properties": {}})(getattr(t, "inputSchema", {})),
                    },
                }
                for t in all_remote_tools
            ]
            
    return tools_payload, server_tools

@activity.defn(name="ExecuteTool")
async def execute_tool_activity(  # noqa: D401 â€“ imperative style
    tool_call: ToolCall,
    mcp_server_config: MCPServerConfig,  
) -> ToolCallResult:
    """Proxy *tool_call* execution to the given *mcp_server*.

    Parameters
    ----------
    tool_call
        The tool invocation request generated by the LLM / agent.
    mcp_server
        Logical name of the MCP server to use.
    """
    try:
        session = await default_manager().get_session(mcp_server_config)

        
        mcp_result = await session.call_tool(tool_call.name, tool_call.arguments)  
        def _serialise_part(part: Any) -> str:
            if getattr(part, "type", "text") == "text":
                return str(getattr(part, "text", part))
            return "<non-text result>"

        content_json = json.dumps([_serialise_part(p) for p in getattr(mcp_result, "content", [])])

        return ToolCallResult(tool_call_id=tool_call.id, content=content_json) 
    except Exception as e:
        logger.error(f"Error executing tool {tool_call.name}: {e}")
        raise e
